import{_ as a,c as i,o as e,a3 as l}from"./chunks/framework.BM2i9-bh.js";const v=JSON.parse('{"title":"常规","description":"","frontmatter":{},"headers":[],"relativePath":"src/知识库/vue2篇/index1.md","filePath":"src/知识库/vue2篇/index1.md"}'),t={name:"src/知识库/vue2篇/index1.md"},s=l(`<h1 id="常规" tabindex="-1">常规 <a class="header-anchor" href="#常规" aria-label="Permalink to &quot;常规&quot;">​</a></h1><h2 id="解决花括号问题" tabindex="-1">解决花括号问题 <a class="header-anchor" href="#解决花括号问题" aria-label="Permalink to &quot;解决花括号问题&quot;">​</a></h2><p>标签样式中加 v-cloak v-克楼克</p><p>在css中加</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">v-cloak</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">none</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !important</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="vue中data为什么是一个函数" tabindex="-1">vue中data为什么是一个函数 <a class="header-anchor" href="#vue中data为什么是一个函数" aria-label="Permalink to &quot;vue中data为什么是一个函数&quot;">​</a></h2><p>vue的data是一个函数的原因是，确保每一个vue组件的实例是唯一的，数据是不共享的，更容易维护的</p><h2 id="vue的优点-vue的缺点" tabindex="-1">Vue的优点? vue的缺点? <a class="header-anchor" href="#vue的优点-vue的缺点" aria-label="Permalink to &quot;Vue的优点? vue的缺点?&quot;">​</a></h2><p>优点: 渐进式，组件化，轻量级，虚拟dom，响应式，单页面路由，数据与视图分开 缺点: 单页面不利于seo，不支持IE8以下，首屏加载时间长</p><h2 id="v-if和v-show有何区别" tabindex="-1">v-if和v-show有何区别？ <a class="header-anchor" href="#v-if和v-show有何区别" aria-label="Permalink to &quot;v-if和v-show有何区别？&quot;">​</a></h2><ul><li>v-if元素不可见，直接删除DOM，有更高的切换消耗。</li><li>v-show通过设置元素display: none控制显示隐藏，更高的初始渲染消耗。</li></ul><h2 id="为什么v-if和v-for不建议用在同一标签" tabindex="-1">为什么v-if和v-for不建议用在同一标签？ <a class="header-anchor" href="#为什么v-if和v-for不建议用在同一标签" aria-label="Permalink to &quot;为什么v-if和v-for不建议用在同一标签？&quot;">​</a></h2><p>v-for比v-if优先级更高，一起使用的话每次渲染列表时都要执行一次条件判断，造成不必要的计算，影响性能。</p><h2 id="computed-康pu-来的-和watch-喔企-的区别" tabindex="-1">computed(康pu 来的) 和watch(喔企)的区别 <a class="header-anchor" href="#computed-康pu-来的-和watch-喔企-的区别" aria-label="Permalink to &quot;computed(康pu 来的) 和watch(喔企)的区别&quot;">​</a></h2><ul><li>1、computed 默认执行一次，watch默认不会执行</li><li>2、computed 支持缓存，只有依赖数据发生改变，才会重新进行计算；watch 不支持缓存，数据变，直接会触发相应的操作</li><li>3、computed 不支持异步，当computed内有异步操作时无效，无法监听数据的变化；watch 支持异步</li></ul><h2 id="为什么不建议用index做key-为什么不建议用随机数做key" tabindex="-1">为什么不建议用index做key，为什么不建议用随机数做key？ <a class="header-anchor" href="#为什么不建议用index做key-为什么不建议用随机数做key" aria-label="Permalink to &quot;为什么不建议用index做key，为什么不建议用随机数做key？&quot;">​</a></h2><p>用index和用随机数都是同理，随机数每次都在变，做不到专一性，也很消耗性能</p><h2 id="说说nexttick-莱克斯-特克-的用处" tabindex="-1">说说nextTick(莱克斯 特克)的用处？ <a class="header-anchor" href="#说说nexttick-莱克斯-特克-的用处" aria-label="Permalink to &quot;说说nextTick(莱克斯 特克)的用处？&quot;">​</a></h2><p>修改数据时不能马上得到最新的DOM信息，所以需要使用nextTick，在nectTick回调中可以获取最新DOM信息</p><h2 id="vue有那些性能优化" tabindex="-1">Vue有那些性能优化 <a class="header-anchor" href="#vue有那些性能优化" aria-label="Permalink to &quot;Vue有那些性能优化&quot;">​</a></h2><p><strong>编码阶段</strong></p><ul><li>v-if和v-for不一起使用</li><li>v-for保证key的唯一性</li><li>使用keep-alive缓存组件</li><li>v-if和v-show酌情使用</li><li>路由懒加载、异步组件</li><li>图片懒加载</li><li>节流防抖</li><li>第三方模块按需引入</li><li>服务端与渲染</li></ul><p><strong>打包优化</strong></p><ul><li>压缩代码</li><li>使用CDN加载第三方模块</li><li>抽离公共文件</li></ul><p><strong>用户体验</strong></p><ul><li>骨架屏</li><li>客户端缓存</li></ul><p><strong>SEO优化</strong></p><ul><li>预渲染</li><li>服务端渲染</li><li>合理使用 meta 标签</li></ul><h2 id="nexttick的使用和原理" tabindex="-1">nextTick的使用和原理？ <a class="header-anchor" href="#nexttick的使用和原理" aria-label="Permalink to &quot;nextTick的使用和原理？&quot;">​</a></h2><p>功能：可以获取到更新后的DOM，nextTick返回一个Promise，是一个 异步行为。 因为vue采用的是异步更新策略，数据发生变化，DOM节点并不会立刻发生变化，而是开启一个队列，把组件更新函数保存在队列中，同一个事件循环中发生的所有数据变更会异步的批量更新。这一策略导致我们对数据的修改不能立刻的体现在DOM上，此时如果我们想获取更新后的DOM状态，就要使用nextTick。在开发时，一般两个场景用： 1、created中想要获取DOM时； 2、响应式数据变化后获取DOM更新后的状态</p><h2 id="v-model-是如何实现的-语法糖实际是什么" tabindex="-1">v-model 是如何实现的，语法糖实际是什么？ <a class="header-anchor" href="#v-model-是如何实现的-语法糖实际是什么" aria-label="Permalink to &quot;v-model 是如何实现的，语法糖实际是什么？&quot;">​</a></h2><p>Vue 中数据双向绑定是一个指令v-model，可以绑定一个响应式数据到视图，同时视图的变化能改变该值。</p><ul><li>当作用在表单上：通过v-bind:value绑定数据，v-on:input来监听数据变化并修改value</li><li>当作用在组件上：本质上是一个父子通信语法糖，通过props和$emit实现。</li></ul><h2 id="vue-mixin的使用场景" tabindex="-1">vue.mixin的使用场景 <a class="header-anchor" href="#vue-mixin的使用场景" aria-label="Permalink to &quot;vue.mixin的使用场景&quot;">​</a></h2><p>使用场景： Vue.mixin是一种混入（mix-in）技术，可以在多个组件之间共享组件选项，包括生命周期方法、data选项等等，使用Vue.mixin可以将一些通用的功能或逻辑封装起来，让多个组件可共同调用这些相同的逻辑，避免了冗余代码的出现。</p>`,35),n=[s];function o(h,r,d,u,c,p){return e(),i("div",null,n)}const m=a(t,[["render",o]]);export{v as __pageData,m as default};
