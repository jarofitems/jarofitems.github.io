import{_ as a,c as i,o as l,a3 as t}from"./chunks/framework.Dcugq_a2.js";const b=JSON.parse('{"title":"回流与重绘","description":"","frontmatter":{},"headers":[],"relativePath":"src/知识库/JS篇/index5.md","filePath":"src/知识库/JS篇/index5.md"}'),e={name:"src/知识库/JS篇/index5.md"},o=t('<h1 id="回流与重绘" tabindex="-1">回流与重绘 <a class="header-anchor" href="#回流与重绘" aria-label="Permalink to &quot;回流与重绘&quot;">​</a></h1><h2 id="什么是回流" tabindex="-1">什么是回流 <a class="header-anchor" href="#什么是回流" aria-label="Permalink to &quot;什么是回流&quot;">​</a></h2><p>回流 的本质就是重新计算 layout 树。 当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。</p><h2 id="什么是重绘" tabindex="-1">什么是重绘 <a class="header-anchor" href="#什么是重绘" aria-label="Permalink to &quot;什么是重绘&quot;">​</a></h2><p>重绘 的本质就是重新根据分层信息计算了绘制指令。 当改动了可见样式后，就需要重新计算，会引发 重绘 <strong>注意：</strong></p><ul><li>每个页面至少需要一次回流+重绘；</li><li>回流必将引起重绘，而重绘不一定会引起回流；</li><li>改变字体大小会引起回流</li></ul><h2 id="回流发生条件" tabindex="-1">回流发生条件 <a class="header-anchor" href="#回流发生条件" aria-label="Permalink to &quot;回流发生条件&quot;">​</a></h2><ul><li>页面的首次渲染</li><li>浏览器的窗口大小发生变化</li><li>元素内容发生变化</li><li>元素的尺寸或位置发生变化</li><li>元素的字体大小发生变化</li><li>添加或删除可见的DOM元素</li><li>激活CSS伪类</li><li>查询某些属性或者调用某些方法</li></ul><h2 id="回流发生条件-1" tabindex="-1">回流发生条件 <a class="header-anchor" href="#回流发生条件-1" aria-label="Permalink to &quot;回流发生条件&quot;">​</a></h2><p>当 DOM结构发生变化 或者 元素样式 发生改变时，浏览器需要重新计算样式和渲染树，这个过程比较消耗性能</p><h2 id="重绘发生条件" tabindex="-1">重绘发生条件 <a class="header-anchor" href="#重绘发生条件" aria-label="Permalink to &quot;重绘发生条件&quot;">​</a></h2><p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p><h2 id="性能影响" tabindex="-1">性能影响 <a class="header-anchor" href="#性能影响" aria-label="Permalink to &quot;性能影响&quot;">​</a></h2><p>回流比重绘的代价要更高。</p><h2 id="如何避免" tabindex="-1">如何避免 <a class="header-anchor" href="#如何避免" aria-label="Permalink to &quot;如何避免&quot;">​</a></h2><p><strong>CSS</strong></p><ul><li>避免使用table布局。</li><li>尽可能在DOM树的最末端改变class。</li><li>避免设置多层内联样式。</li><li>将动画效果应用到position属性为absolute或fixed的元素上。</li><li>避免使用CSS表达式（例如：calc()）。 <strong>JavaScript</strong></li><li><strong>使用CSS动画代替JavaScript动画</strong>：CSS 动画利用 GPU 加速，在性能方面通常比 JavaScript 动画更高效。</li><li><strong>使元素脱离文档流</strong>：position: absolute/position: fixed/float:left（只是减少回流，不是避免回流）</li><li><strong>避免频繁操作样式</strong>：最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。</li><li><strong>避免频繁操作DOM</strong>：创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</li><li><strong>避免频繁读取会引发回流/重绘的属性</strong>，如果确实需要多次使用，就用一个变量缓存起来。</li><li><strong>对具有复杂动画的元素使用绝对定位</strong>，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li></ul>',17),r=[o];function s(n,c,h,d,u,p){return l(),i("div",null,r)}const g=a(e,[["render",s]]);export{b as __pageData,g as default};
