import{_ as a,c as e,o as i,a3 as s}from"./chunks/framework.Dcugq_a2.js";const g=JSON.parse('{"title":"常规","description":"","frontmatter":{},"headers":[],"relativePath":"src/知识库/JS篇/index1.md","filePath":"src/知识库/JS篇/index1.md"}'),t={name:"src/知识库/JS篇/index1.md"},l=s(`<h1 id="常规" tabindex="-1">常规 <a class="header-anchor" href="#常规" aria-label="Permalink to &quot;常规&quot;">​</a></h1><h2 id="this指向的含义" tabindex="-1">this指向的含义 <a class="header-anchor" href="#this指向的含义" aria-label="Permalink to &quot;this指向的含义&quot;">​</a></h2><p>this对象是在运行时基于函数的执行环境绑定的：</p><ul><li>在全局函数中，this等于window，</li><li>在函数被作为某个对象调用时，this等于那个对象</li></ul><p>不过，匿名函数具有全局性，因此this对象同常指向window</p><h2 id="cookie与sessionstorage、localstorage区别" tabindex="-1">cookie与sessionStorage、localStorage区别 <a class="header-anchor" href="#cookie与sessionstorage、localstorage区别" aria-label="Permalink to &quot;cookie与sessionStorage、localStorage区别&quot;">​</a></h2><h3 id="cookie" tabindex="-1">cookie <a class="header-anchor" href="#cookie" aria-label="Permalink to &quot;cookie&quot;">​</a></h3><p>cookie若不设置时间，则表示这个cookie的生命期为浏览器会话期间，在没设置过期时间的情况关闭浏览器窗口，cookie就会消失。这种生命期为浏览器会话期的cookie被称为会话cookie。</p><h3 id="localstorage" tabindex="-1">localStorage <a class="header-anchor" href="#localstorage" aria-label="Permalink to &quot;localStorage&quot;">​</a></h3><p>localStorage的生命周期是永久性的。假若使用localStorage存储数据，即使关闭浏览器，也不会让数据消失，除非主动的去删除数据</p><h3 id="sessionstorage" tabindex="-1">sessionStorage <a class="header-anchor" href="#sessionstorage" aria-label="Permalink to &quot;sessionStorage&quot;">​</a></h3><p>sessionStorage 的生命周期是在浏览器关闭前。也就是说，在整个浏览器未关闭前，其数据一直都是存在的</p><h2 id="闭包" tabindex="-1">闭包 <a class="header-anchor" href="#闭包" aria-label="Permalink to &quot;闭包&quot;">​</a></h2><p><strong>定义：内部函数的作用域链依然保持着对父函数活动对象的引用，就是闭包</strong></p><p>闭包有两个作用：</p><ul><li>第一个就是可以读取自身函数外部的变量（沿着作用域链寻找）</li><li>第二个就是让这些外部变量始终保存在内存中</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lives </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 50</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    lives </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 调用</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><h3 id="什么是闭包" tabindex="-1">什么是闭包？ <a class="header-anchor" href="#什么是闭包" aria-label="Permalink to &quot;什么是闭包？&quot;">​</a></h3><ul><li>函数内嵌套函数</li><li>子函数引用了父函数的相关变量</li></ul><h3 id="为什么要函数嵌套函数" tabindex="-1">为什么要函数嵌套函数？ <a class="header-anchor" href="#为什么要函数嵌套函数" aria-label="Permalink to &quot;为什么要函数嵌套函数？&quot;">​</a></h3><p>是因为需要局部变量，所以才把变量放在一个函数里</p><ul><li>为什么要return呢？ 因为如果不 return，你就无法使用这个闭包。把 return test改成 window.test= test也是一样的，只要让外面可以访问到这个 test函数就行了</li></ul><h3 id="闭包的作用" tabindex="-1">闭包的作用？ <a class="header-anchor" href="#闭包的作用" aria-label="Permalink to &quot;闭包的作用？&quot;">​</a></h3><p>1，常常用来间接访问一个变量 2，函数内部可以使用函数外部的变量 闭包使用场景：常用来封装组件和插件，比如：表单操作和倒计时功能等等。 闭包特点：长期驻留在内存中，可以缓存数据，可以隔离作用域，避免全局污染。</p><h2 id="var、let和const的区别" tabindex="-1">var、let和const的区别 <a class="header-anchor" href="#var、let和const的区别" aria-label="Permalink to &quot;var、let和const的区别&quot;">​</a></h2><ul><li>var可以重复声明，全局调用，没有块级作用域</li><li>let不能重复声明，有块级作用域，变量可以修改</li><li>const 不能重复声明，有块级作用域，常量不可以修改</li></ul><h2 id="解释null和undefined" tabindex="-1">解释null和undefined <a class="header-anchor" href="#解释null和undefined" aria-label="Permalink to &quot;解释null和undefined&quot;">​</a></h2><p>JavaScript 中有两种底层类型：null 和 undefined。它们代表了不同的含义：</p><ul><li>尚未初始化：undefined；</li><li>空值：null。</li></ul><h2 id="轮询" tabindex="-1">轮询 <a class="header-anchor" href="#轮询" aria-label="Permalink to &quot;轮询&quot;">​</a></h2><p>定义：就是每隔一个固定的时间就向后端发起一个异步请求。 常用到的方式：setTimeout和setInterval，</p><h3 id="setinterval方式" tabindex="-1">setInterval方式： <a class="header-anchor" href="#setinterval方式" aria-label="Permalink to &quot;setInterval方式：&quot;">​</a></h3><p>优点：就是写法简单； 缺点：就是无限的循环，不太好把控。</p><p>总的来说轮询会比较浪费网络资源，而且不管请求有没有响应，都会接着发下一次请求，影响性能。</p><h3 id="长轮询" tabindex="-1">长轮询 <a class="header-anchor" href="#长轮询" aria-label="Permalink to &quot;长轮询&quot;">​</a></h3><p>定义：就是下一次请求的发出的前提条件就是前一次请求响应成功。 通常采用promise语法来写</p><h2 id="定时器" tabindex="-1">定时器 <a class="header-anchor" href="#定时器" aria-label="Permalink to &quot;定时器&quot;">​</a></h2><h3 id="一次性定时器" tabindex="-1">一次性定时器 <a class="header-anchor" href="#一次性定时器" aria-label="Permalink to &quot;一次性定时器&quot;">​</a></h3><p>setTimeout(callback, delay, rest) (色特特闷欧特) self.time = setTimeout(() =&gt; {</p><p>}, 1000);</p><h3 id="取消定时器-cleartimeout-克尼尔特闷欧特" tabindex="-1">取消定时器 clearTimeout (克尼尔特闷欧特) <a class="header-anchor" href="#取消定时器-cleartimeout-克尼尔特闷欧特" aria-label="Permalink to &quot;取消定时器  clearTimeout  (克尼尔特闷欧特)&quot;">​</a></h3><p>clearTimeout(self.time)</p><h3 id="定时加载定时器" tabindex="-1">定时加载定时器 <a class="header-anchor" href="#定时加载定时器" aria-label="Permalink to &quot;定时加载定时器&quot;">​</a></h3><p>setInterval(callback, delay, rest) (色特因特儿佛) self.time = setInterval(() =&gt; {</p><p>}, 1000);</p><h3 id="取消定时器-clearinterval-克里尔因特儿佛" tabindex="-1">取消定时器 clearInterval (克里尔因特儿佛) <a class="header-anchor" href="#取消定时器-clearinterval-克里尔因特儿佛" aria-label="Permalink to &quot;取消定时器 clearInterval  (克里尔因特儿佛)&quot;">​</a></h3><p>clearInterval(self.time)</p><h2 id="事件委托" tabindex="-1">事件委托 <a class="header-anchor" href="#事件委托" aria-label="Permalink to &quot;事件委托&quot;">​</a></h2><p>什么是事件委托：通俗的讲，事件就是onclick，onmouseover，onmouseout，等就是事件，委托呢，就是让别人来做，这个事件本来是加在某些元素上的，然而你却加到别人身上来做，完成这个事件。 也就是：利用冒泡的原理，把事件加到父级上，触发执行效果。 好处： 1、提高性能 2、新添加的原生还会有之前的事件</p>`,49),n=[l];function r(o,h,c,d,p,k){return i(),e("div",null,n)}const b=a(t,[["render",r]]);export{g as __pageData,b as default};
