import{_ as e,c as a,o as s,a3 as i,m as t}from"./chunks/framework.Dcugq_a2.js";const b=JSON.parse('{"title":"普通函数与箭头函数区别","description":"","frontmatter":{},"headers":[],"relativePath":"src/知识库/JS篇/index2.md","filePath":"src/知识库/JS篇/index2.md"}'),l={name:"src/知识库/JS篇/index2.md"},n=i('<h1 id="普通函数与箭头函数区别" tabindex="-1">普通函数与箭头函数区别 <a class="header-anchor" href="#普通函数与箭头函数区别" aria-label="Permalink to &quot;普通函数与箭头函数区别&quot;">​</a></h1><h2 id="普通函数" tabindex="-1">普通函数： <a class="header-anchor" href="#普通函数" aria-label="Permalink to &quot;普通函数：&quot;">​</a></h2><ul><li>普通函数的this总是指向它的直接调用者。</li><li>在严格模式下，没找到直接调用者，则函数中的this是undefined。</li><li>在默认模式下（非严格模式），没找到直接调用者，则函数中的this指向window。</li></ul><h2 id="箭头函数" tabindex="-1">箭头函数： <a class="header-anchor" href="#箭头函数" aria-label="Permalink to &quot;箭头函数：&quot;">​</a></h2><ul><li>箭头函数中的this始终指向其父级作用域中的this。换句话说，箭头函数会捕获其所在的上下文的this值，作为自己的this值。任何方法都改变不了其指向，如call(), bind(), apply()。在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用，它与调用时的上下文无关。</li><li>普通函数可以使用 new 创建实例，箭头函数不行</li></ul>',5),o=t("p",{"console.log(args)":""},"此外，箭头函数也没有没有自己的this，arguments，new target（ES6）和 super(ES6)。，它调用自己的参数只能使用（…args）=>",-1),r=t("p",null,[t("strong",null,"箭头函数的this永远不会变，call、apply、bind也无法改变")],-1),c=t("p",null,[t("strong",null,"箭头函数没有原型prototype")],-1),d=t("p",null,[t("strong",null,"箭头函数不能当成一个构造函数")],-1),h=[n,o,r,c,d];function _(u,p,m,f,x,S){return s(),a("div",null,h)}const P=e(l,[["render",_]]);export{b as __pageData,P as default};
