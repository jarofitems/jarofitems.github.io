import{_ as a,c as e,o as t,a3 as i}from"./chunks/framework.BM2i9-bh.js";const m=JSON.parse('{"title":"协商缓存和强缓存的区别","description":"","frontmatter":{},"headers":[],"relativePath":"src/知识库/JS/index15.md","filePath":"src/知识库/JS/index15.md"}'),r={name:"src/知识库/JS/index15.md"},l=i('<h1 id="协商缓存和强缓存的区别" tabindex="-1">协商缓存和强缓存的区别 <a class="header-anchor" href="#协商缓存和强缓存的区别" aria-label="Permalink to &quot;协商缓存和强缓存的区别&quot;">​</a></h1><h2 id="什么是缓存" tabindex="-1">什么是缓存？ <a class="header-anchor" href="#什么是缓存" aria-label="Permalink to &quot;什么是缓存？&quot;">​</a></h2><p>浏览器缓存(Brower Caching)是浏览器对之前请求过的文件进行缓存，以便下一次访问时重复使用，节省带宽，提高访问速度，降低服务器压力</p><h2 id="缓存基本原理" tabindex="-1">缓存基本原理 <a class="header-anchor" href="#缓存基本原理" aria-label="Permalink to &quot;缓存基本原理&quot;">​</a></h2><p>浏览器在加载资源时，根据请求头的expires和cache-control来判断是否命中强缓存，是则直接从缓存中读取资源，不发送请求到服务器 如果没有命中强缓存，浏览器会发送请求至服务器，通过last-modified和etag验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取数据 如果前面两者都没有命中，直接从服务器加载资源</p><h2 id="强缓存" tabindex="-1">强缓存 <a class="header-anchor" href="#强缓存" aria-label="Permalink to &quot;强缓存&quot;">​</a></h2><p>使用强缓存策略时，如果缓存资源有效，浏览器会从本地读取缓存资源并返回200，不必再向服务器发起请求。强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。</p><h2 id="协议缓存" tabindex="-1">协议缓存 <a class="header-anchor" href="#协议缓存" aria-label="Permalink to &quot;协议缓存&quot;">​</a></h2><p>在使用协商缓存时，会先向服务器发送一个请求，如果资源没有发生修改，则请求返回304状态，让浏览器使用本地缓存。如果资源发生修改，则返回修改后的内容</p><h2 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h2><ul><li>强缓存优先级高于协商缓存</li><li>协商缓存不论命中与否都会发送一次请求</li><li>强缓存返回200，协商缓存命中返回304</li><li>Ctrl+F5 会强制刷新会跳过所有缓存，而F5刷新跳过强缓存，但是会检查协商缓存。</li></ul><h2 id="为什么需要浏览器缓存" tabindex="-1">为什么需要浏览器缓存？ <a class="header-anchor" href="#为什么需要浏览器缓存" aria-label="Permalink to &quot;为什么需要浏览器缓存？&quot;">​</a></h2><p>使用浏览器缓存，有以下优点：</p><ul><li>减少了服务器的负担，提高了网站的性能</li><li>加快了客户端网页的加载速度</li><li>减少了多余网络数据传输</li></ul>',14),o=[l];function n(h,c,s,d,_,p){return t(),e("div",null,o)}const f=a(r,[["render",n]]);export{m as __pageData,f as default};
