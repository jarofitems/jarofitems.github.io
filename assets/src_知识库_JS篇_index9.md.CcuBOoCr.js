import{_ as a,c as t,o as e,a3 as r}from"./chunks/framework.Dcugq_a2.js";const P=JSON.parse('{"title":"TCP三次握手和四次挥手","description":"","frontmatter":{},"headers":[],"relativePath":"src/知识库/JS篇/index9.md","filePath":"src/知识库/JS篇/index9.md"}'),o={name:"src/知识库/JS篇/index9.md"},i=r('<h1 id="tcp三次握手和四次挥手" tabindex="-1">TCP三次握手和四次挥手 <a class="header-anchor" href="#tcp三次握手和四次挥手" aria-label="Permalink to &quot;TCP三次握手和四次挥手&quot;">​</a></h1><h2 id="tcp连接-三次握手" tabindex="-1">TCP连接“三次握手” <a class="header-anchor" href="#tcp连接-三次握手" aria-label="Permalink to &quot;TCP连接“三次握手”&quot;">​</a></h2><img src="https://jitems.gitee.io/myblog/docs/zs10.png" alt="solar"><p>简单示意图： 1、一次握手：客户端==&gt;服务端，发送带有 SYN 标志的数据包 2、二次握手：服务端==&gt;客户端，发送带有 SYN/ACK 标志的数据包 3、三次握手：客户端==&gt;服务端，发送带有带有 ACK 标志的数据包</p><h2 id="为什么要三次握手" tabindex="-1">为什么要三次握手？ <a class="header-anchor" href="#为什么要三次握手" aria-label="Permalink to &quot;为什么要三次握手？&quot;">​</a></h2><p>三次握手的目的是建立可靠的通信信道</p><h2 id="为什么tcp客户端最后还要发送一次确认呢" tabindex="-1">为什么TCP客户端最后还要发送一次确认呢？ <a class="header-anchor" href="#为什么tcp客户端最后还要发送一次确认呢" aria-label="Permalink to &quot;为什么TCP客户端最后还要发送一次确认呢？&quot;">​</a></h2><p>一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误</p><h2 id="tcp-断开-四次挥手" tabindex="-1">TCP 断开“四次挥手” <a class="header-anchor" href="#tcp-断开-四次挥手" aria-label="Permalink to &quot;TCP 断开“四次挥手”&quot;">​</a></h2><img src="https://jitems.gitee.io/myblog/docs/zs11.png" alt="solar"><p>简单示意图： 1、一次挥手：客户端==&gt;服务端，发送一个 FIN，用来关闭客户端到服务器的数据传送 2、二次挥手：服务端==&gt;客户端，收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号 3、三次挥手：服务端==&gt;客户端，关闭与客户端的连接，发送一个FIN给客户端 4、四次挥手：客户端==&gt;服务端，发回 ACK 报文确认，并将确认序号设置为收到序号加。</p><h2 id="为什么要四次挥手" tabindex="-1">为什么要四次挥手？ <a class="header-anchor" href="#为什么要四次挥手" aria-label="Permalink to &quot;为什么要四次挥手？&quot;">​</a></h2><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p>',13),s=[i];function c(n,l,h,d,p,_){return e(),t("div",null,s)}const u=a(o,[["render",c]]);export{P as __pageData,u as default};
