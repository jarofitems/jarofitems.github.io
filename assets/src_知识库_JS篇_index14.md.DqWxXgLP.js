import{_ as a,c as e,o as t,a3 as i}from"./chunks/framework.BM2i9-bh.js";const m=JSON.parse('{"title":"浏览器的垃圾回收机制","description":"","frontmatter":{},"headers":[],"relativePath":"src/知识库/JS篇/index14.md","filePath":"src/知识库/JS篇/index14.md"}'),r={name:"src/知识库/JS篇/index14.md"},l=i('<h1 id="浏览器的垃圾回收机制" tabindex="-1">浏览器的垃圾回收机制 <a class="header-anchor" href="#浏览器的垃圾回收机制" aria-label="Permalink to &quot;浏览器的垃圾回收机制&quot;">​</a></h1><p>**垃圾回收：**JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不再参与运行时，就需要系统收回被占用的内存空间。​如果不及时清理，会造成系统卡顿、内存溢出，这就是垃圾回收。</p><ul><li>JS 具有自动垃圾回收机制。垃圾收集器会按照固定的时间间隔周期性的执行。</li><li>JS 常见的垃圾回收方式：标记清除、引用计数方式</li></ul><h2 id="哪些情况会导致内存泄漏" tabindex="-1">哪些情况会导致内存泄漏 <a class="header-anchor" href="#哪些情况会导致内存泄漏" aria-label="Permalink to &quot;哪些情况会导致内存泄漏&quot;">​</a></h2><ul><li>意外的全局变量：由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li><li>被遗忘的计时器或回调函数：设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li><li>脱离 DOM 的引用：获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</li><li>闭包：不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li></ul><h2 id="额外提升" tabindex="-1">额外提升 <a class="header-anchor" href="#额外提升" aria-label="Permalink to &quot;额外提升&quot;">​</a></h2>',6),o=[l];function n(s,c,_,d,h,u){return t(),e("div",null,o)}const f=a(r,[["render",n]]);export{m as __pageData,f as default};
